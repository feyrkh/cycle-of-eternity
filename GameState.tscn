[gd_scene load_steps=2 format=2]

[sub_resource type="GDScript" id=1]
script/source = "extends Node

var OrganizerData = load(\"res://ui/organizer/OrganizerData.gd\")

var UI
var curScene = null
var bootstrapScene = null # Name of the scene to load at the start of GameScene. Used when starting a fresh game 
var loadingSaveFile = null # Name of the save file to load at the start of GameScene. Used when restoring the game from the title screen, or other times when the GameScene isn't loaded

var settings = {
	'playerName': 'Master',
	'schoolName': \"Heaven's Shadow\",
	'helperName': 'Ren Xiu',
}

var quest = {
	'tutorial':'start'
}

var resources = {
	\"coin\": 500
}

# Translation from resources (ex: from the results of decrees) into human-friendly names
# n: name (human-friendly name)
# d: description
# hide: (should this be hidden from decree results)
# levels: [[-50, 'extremely low'], [-25, 'very low'], [-10, 'low'], [10, 'neutral'], [25, 'high'], [50, 'very high'], 'extremely high']
# labor: If true, then this resource represents labor that must be supplied to complete a decree or other project. When time passes, available resources will be accumulated into the project.
# transient: If true, this resource disappears after time passes - it must be used immediately. For example, \"unskilled labor\" or a temporary weather phenomenon.
var resourceData = {
	\"coin\": {\"n\":\"jade chips\", \"d\":\"The coin of the common folk. While the Emperor's mandate suffices to requisition anything you truly need, gifts of jade will help avoid ill feelings.\", \"labor\":true},
	\"laborAdmin\": {\"n\":\"bureaucratic labor\", \"d\":\"Work performed by professional bureaucrats and functionaries.\", \"labor\":true, \"transient\":true, \"suffix\":\"man-day\"},
	\"laborScribe\": {\"n\":\"scribe labor\", \"d\":\"Work performed by skilled scribes.\", \"labor\":true, \"transient\":true, \"suffix\":\"day\"},
	\"laborUnskilled\": {\"n\":\"unskilled labor\", \"d\":\"Unskilled labor provided by work crews.\", \"labor\":true, \"transient\":true, \"suffix\":\"day\"},
	\"workCrew\": {\"n\":\"workers\", \"entity\":{\"org\":\"main\", \"folderId\":\"new\", \"data\":\"res://data/producer/workCrew.json\", \"mergeId\":null}, \"d\":\"Work crews perform common manual labor that is beneath the station of disciples and examplars - farming, construction, and so forth.\", \"suffix\":\"crew\"},
	\"villageDiplomacy\": {\"n\":\"villager reaction\", \"levels\":[[-60, \"infuriated\"], [-30, \"resentful\"], [-15, \"insulted\"], [-5, \"irritated\"], [5, \"neutral\"], [15, \"pleased\"], [30, \"happy\"], [60, \"honored\"], \"ecstatic\"]},
}

var _organizers = {}

var attentionTimer:Timer

func _ready():
	attentionTimer = Timer.new()
	attentionTimer.one_shot = false
	attentionTimer.autostart = true
	add_child(attentionTimer)
	attentionTimer.start(0.1)

func get_resource_name(resourceId):
	var resource = resourceData.get(resourceId, {})
	return resource.get('n', resourceId)

func get_resource_description(resourceId):
	var resource = resourceData.get(resourceId, {})
	return resource.get('d')

func get_resource_level(resourceId, value):
	var resource = resourceData.get(resourceId, {})
	var levels = resource.get('levels')
	if levels:
		for level in levels:
			if level is String: return level
			if value <= level[0]: return level[1]
		return levels[levels.size()-1][1]
	var suffix
	if value == 1: 
		suffix = resource.get('suffix')
	else: 
		suffix = resource.get('psuffix')
		if !suffix: 
			suffix = resource.get('suffix')
			if suffix: suffix = suffix + 's'
	if suffix: value = str(value)+' '+suffix
	return str(value)

# Returns like: {\"workers\": {amt: 1, f_amt: \"1 work crew\", k: \"numWorkers\"}}
# Good for getting the human-friendly sortable keys for displaying resources in alphabetical order
func get_friendly_resource_map(resourceMap:Dictionary)->Dictionary:
	var retval = {}
	for k in resourceMap.keys():
		retval[get_resource_name(k)] = {\"amt\":resourceMap[k], \"f_amt\": get_resource_level(k, resourceMap[k]), \"k\": k}
	return retval

func reset_transient_resources():
	for k in resources.keys():
		if resourceData.get(k, {}).get('transient', false): resources.erase(k)

func add_resource(k, amt, source):
	print('adding ', amt, ' ', k, ' from ', source)
	var data = resourceData.get(k, {})
	if data.get('entity'):
		var entityData = data.get('entity')
		if entityData.get('mergeId'): add_merged_entity_resource(k, amt, source, data)
		else: 
			amt = int(amt)
			if amt < 1: amt = 0
			if amt > 10: 
				printerr(\"Sorry, can't add more than 10 entities of a single type at a time...surely this must have been caused by a bug! type=\", k, \"; amt=\", amt, \"; src=\", source)
				amt = 10
			var org = get_organizer_data(entityData.get('org', 'main'))
			var entityCmdJson = Util.load_json_file(entityData.get('data',{}))
			for i in range(amt):
				var newName = entityData.get('name')
				if !newName:
					newName = NameGenerator.generate(k)
				org.add_entry(newName+'^isUnread', entityData.get('data'), null, entityData.get('folderId'), entityData.get('entryScene', 'OrganizerEntry'))
				
	resources[k] = resources.get(k, 0) + amt

func add_merged_entity_resource(resourceName, amt, source, entityData):
	printerr('Not implemented yet')

func produce_resources():
	var addedResources = {}
	for organizerData in _organizers.values():
		var newResources = organizerData.collect_produced_resources()
		for k in newResources.keys():
			var amt = newResources.get(k, 0)
			addedResources[k] = addedResources.get(k, 0) + amt
			add_resource(k, amt, null)
	return addedResources

func consume_resource(resourceName, amt, projectName):
	resources[resourceName] = resources.get(resourceName, 0) - amt
	print(projectName, ' consumed ', amt, ' ', get_resource_name(resourceName))

func deserialize_organizer_entry(valData):
	if valData is Dictionary:
		var dataType = int(valData.get('dt', 0))
		match dataType:
			Util.DATATYPE_DICT: pass 
			Util.DATATYPE_DECREE:
				var deserData = DecreeData.new()
				deserData.deserialize(valData)
				valData = deserData
	return valData
	
func serialize_world()->String:
	UI.save_organizers()
	settings['leftOrganizerName'] = UI.leftOrganizer.organizerDataName
	settings['rightOrganizerName'] = UI.rightOrganizer.organizerDataName
	settings['uiTextInterface'] = UI.serialize_text_interface()
	var retval = {
		'settings':settings,
		'quest':quest,
		'organizers':{},
		'resources':resources
	}
	for k in _organizers.keys():
		if k == 'Null': continue
		var serializedOrganizer = _organizers[k].serialize()
		retval.organizers[k] = serializedOrganizer
	return to_json(retval)

func refresh_organizers():
	load_organizers(true)

func save_organizers():
	UI.save_organizers()

func load_organizers(skipSave=false):
	var leftOrganizerName = GameState.settings.get('leftOrganizerName', 'main')
	var rightOrganizerName = GameState.settings.get('rightOrganizerName')
	if leftOrganizerName: UI.load_left_organizer(leftOrganizerName, skipSave)
	if rightOrganizerName: UI.load_right_organizer(rightOrganizerName, skipSave)

func change_right_organizer(organizerName):
	UI.load_right_organizer(organizerName, false)

func deserialize_world(worldJson):
	var serializedWorld = parse_json(worldJson)
	settings = serializedWorld.settings
	quest = serializedWorld.get('quest', {})
	resources = serializedWorld.get('resources', {})
	_organizers = {}
	var dummyOrg = OrganizerData.new() # needed because gdscript 3 doesn't support self-reference of classes from static functions :eyeroll:
	for k in serializedWorld.organizers:
		var deserializedOrganizer = dummyOrg.deserialize(serializedWorld.organizers[k])
		_organizers[k] = deserializedOrganizer
	if UI:
		load_organizers(true)
		UI.deserialize_text_interface(settings.get('uiTextInterface'))
	loadScene(settings['curSceneName'], settings['curSceneSettings'])
		
func save_world(saveSlot, serializedWorld):
	var dir:Directory = Directory.new()
	dir.make_dir('user://save')
	var file = File.new()
	file.open(\"user://save/%s.dat\"%saveSlot, File.WRITE)
	file.store_string(serializedWorld)
	file.close()

func load_world(saveSlot):
	randomize()
	var file = File.new()
	file.open(\"user://save/%s.dat\"%saveSlot, File.READ)
	var content = file.get_as_text()
	file.close()
	deserialize_world(content)
	
func add_organizer(organizerName, organizerData):
	organizerData.name = organizerName
	_organizers[organizerName] = organizerData

func loadScene(newSceneName:String, newSceneData:Dictionary):
	Conversation.reset()
	if UI && UI.textInterface: UI.textInterface.reset()
	if curScene && curScene.has_method('shutdown_scene'): 
		curScene.shutdown_scene()
	if curScene: curScene.queue_free()
	var newScene = load('res://scene/'+newSceneName+'.tscn').instance()
	if newScene.has_method('startup_scene'): newScene.startup_scene(newSceneData)
	curScene = newScene
	settings['curSceneName'] = newSceneName
	settings['curSceneSettings'] = newSceneData
	Event.emit_signal(\"new_scene_loaded\", newScene)

func get_organizer_data(organizerName:String):
	if !_organizers.has(organizerName):
		_organizers[organizerName] = OrganizerData.new()
		_organizers[organizerName].name = organizerName
	return _organizers[organizerName]

func add_popup(popup):
	UI.add_popup(popup)

func run_command(cmd, data:Dictionary, sourceNode:Node=null):
	if cmd is Array:
		for c in cmd:
			run_command(cmd, data, sourceNode)
		return
	match cmd:
		'decreeGen': cmd_decree_gen(data, sourceNode)
		'scene': cmd_scene(data, sourceNode)
		'item': cmd_item(data, sourceNode)
		'msg': cmd_msg(data, sourceNode)
		'placeable': cmd_placeable(data, sourceNode)
		'quicksave': cmd_quicksave()
		'quickload': cmd_quickload()
		_: printerr('Invalid command: ', cmd, '; data=', data, '; sourceNode=', sourceNode.name)

func cmd_decree_gen(data:Dictionary, sourceNode):
	var orgName = data.get('org').format(settings) # assume org is a string, and it might be a string like \"{rightOrganizerName}\" so we can create decrees that target your current location instead of a fixed location
	var folderId = data.get('folderId') # optional, the ID of the root folder to put this into, if it can be found - ex 'outbox'
	var entryId = data.get('entryId') # optional, the ID to apply to the new decree...probably need to use a template var for this to be useful
	if entryId: entryId = entryId.format(settings)
	var decreeJsonFile = data.get('decreeFile') # JSON file holding the decree we're going to build
	var decreeData = load(\"res://decree/DecreeData.gd\").new()
	decreeData.init_from_file(decreeJsonFile)
	var targetOrg = GameState.get_organizer_data(orgName)
	targetOrg.add_entry(decreeData.projectName, decreeData, entryId, folderId)
	refresh_organizers()
	decreeData.on_organizer_entry_clicked(null) # simulate a click so the decree pops up
	
# msg - text to display on the popup
func cmd_msg(data:Dictionary, sourceNode):
	Event.emit_signal('msg_popup', data, sourceNode)
	
# msg - text to display on the popup
# produce - list of resources that are produced
func cmd_item(data:Dictionary, sourceNode):
	var produces = data.get('produce', {})
	var friendlyProduces = get_friendly_resource_map(produces)

	var friendlyKeys = friendlyProduces.keys()
	friendlyKeys.sort()
	var productionNote = \"Weekly production:\\n\"
	for k in friendlyKeys:
		productionNote += \"%s: %s\\n\" % [k, friendlyProduces[k][\"f_amt\"]]
		
	var descriptionNote = Util.load_text_file(data.get('msg', ''))
	var popupData =  {
		\"msg\": \"%s\\n---\\n%s\"%[descriptionNote, productionNote],
	}
	if data.get('img'): popupData['img'] = data.get('img')
	
	Event.emit_signal('msg_popup', popupData, sourceNode)

func cmd_placeable(data, sourceNode):
	var itemShadow:Sprite = Sprite.new()
	itemShadow.texture = load(data.get('img'))
	itemShadow.modulate.a = 0.5
	Event.emit_signal('place_item', itemShadow, data, sourceNode)

func cmd_quicksave():
	print('quicksaving')
	var world = serialize_world()
	print('World: ', world)
	save_world('quicksave', world)
	
func cmd_quickload():
	print('quickloading')
	load_world('quicksave')
	

# scene - name of the scene (not 'res://scene/office.tscn', but just 'office')
# deleteSourceNodeAfterTransition - usually for deleting a choice-type item from an Organizer after you click it
# keepCharacter - don't hide any character portrait that's currently displayed in the UI
# keepText - don't clear any text buffered in the UI
func cmd_scene(data:Dictionary, sourceNode):
#	if settings.get('curSceneName') == data.get('scene'): 
#		print(\"Not changing scenes, we're already in the right place\")
#		return
	if sourceNode && data.get('deleteSourceNodeAfterTransition'): sourceNode.queue_free()
	if !data.get('keepCharacter'): Event.hide_character()
	if !data.get('keepText'): Event.clear_text()
	loadScene(data.get('scene'), data)
"

[node name="GameState" type="Node"]
script = SubResource( 1 )
